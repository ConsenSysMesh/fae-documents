# Ethereum emulation

It should be possible to translate Ethereum transactions into Fae ones, in such a way that the contracts they create are Fae contracts, and such that contract and transaction calls are parallelizable via Fae's laziness.  This will add a scalability layer to Ethereum without altering its protocol at all.  This document sketches a way I think this could work.

## What this is not: an EVM contract

It is trivial (but a lot of work) to implement the EVM as a single Fae contract.  This contract would contain the entire state of the Ethereum database as it evolves, and function essentially as an isolated executable that processes EVM bytecode passed to it via the contract's argument.  This implementation enjoys *none* of the benefits of Fae: all Ethereum transactions are calls to the same contract, and calls to any one contract are strictly ordered, so Fae's laziness does not allow any parallelization.  There is no point in doing such an implementation except to technically embed the Ethereum chain as a walled garden inside the larger Fae system.

The design I actually propose brings Fae-emulated Ethereum contracts “closer to the metal”, without the opaque layer of an additional virtual machine contract tainting each one.

## Ethereum vs. Fae contracts

The big difference between Fae and Ethereum is the contract calling convention: in Fae, contract calls must be declared up front in a transaction, while Ethereum allows inline calls by contract creation and existing contract code.  This ability is the root of the non-scalability of Ethereum, because it makes the contract call tree undecidable by static analysis, so all transactions must be executed in order to flush out all potential calls even to just one contract.

An Ethereum transaction *in execution* can be interpreted as a sequence of Fae transactions.  Namely, let the Ethereum code run until one of the instructions `CALL`, `CALLCODE`, or `DELEGATECALL` is reached.  At that point, the parameters to that instruction may be collected and the current Fae transaction ended, returning these data and whatever else is necessary to continue execution of the Ethereum code.  The Fae client may then interpret this return value as an instruction to generate a *new transaction* that has as its input the call that was interrupted, whose return value is then passed along with the continuation data to the contract that was interrupted, allowing it to continue.  In short, an Ethereum transaction is a sequence of Fae transactions broken by contract calls.

## Synchronization

The scheme outlined in the previous paragraph is sufficient for a *single* Fae client to decompose an Ethereum transaction.  However, if the transaction is processed by this client *before* it is placed in a block, the state of the Ethereum database may be different in the block it eventually ends up in, and this difference can affect the calls the Ethereum code makes, and therefore, the Fae transactions it becomes.  If a client is to place the decomposed Fae transactions into a Fae block, then it must be sure that the block contains all previous Ethereum transactions that it had already run when doing the decomposition.

Fortunately, this is no more than saying that the Fae blocks generated by a client must contain the Ethereum transaction-pieces in the same order as they occur in the Ethereum blocks, without interleaving the pieces of different Ethereum transactions.  This can be accomplished simply by adding decomposed transactions to a Fae block under construction as the client reads them from an Ethereum block.  This is essentially the same way that the client would create a block anyway: adding transactions in the order they are received.

When a decomposed transaction is run, therefore, it is guaranteed to follow all transactions in its own block that the client that created that block had already run on top of the consensus blockchain when doing the decomposition; in addition, this block is constructed with an explicit parent, so it itself follows all decomposed transactions that were already in the consensus blockchain are the same for all clients.

## Standalone versus integrated emulation

As it stands, this scheme is sufficient to run a Fae client that is dedicated to being an Ethereum emulator and has *no other blocks or transactions* aside from those in the Ethereum blockchain.  Even this limited usage is beneficial, since decomposing transactions enables Fae's laziness to apply to Ethereum code.  However, it does not provide the ultimate form of blockchain-in-blockchain experience: interoperability.

Interoperability of blockchains is the following situation:

* Blockchains A and B exist and have their clients;
* Every transaction of B is also a transaction of A, and they appear in the same order;
* Transactions in A may call at least a subset of the contracts in B.

For example, Blockchain A is Fae and Blockchain B is Ethereum.  The main concern in such a situation is the *governance* of Blockchain B by the larger Blockchain A: the primary (for example, the longest or highest-difficulty) chain in B may not be contained in the primary chain of A, and therefore, either an A client cannot also be a conforming B client, or the A blockchain must have the “right of first refusal” for B blockchains, overriding the consensus mechanism in the B network.  Both of these situations must be avoided.

If Blockchain A is to host other blockchains B, its chain selection mechanism must be sensitive to that of B.  It must allow B to change primary chains without affecting transactions in A proper, or at least, it must be possible for this change to make a recoverable, contractually safe change in A.  Fortunately, Fae's lazy contract calls mean that it is possible to statically identify transactions that would be affected by a change.  

As an example, suppose a Fae contract F obtains ether from an Ethereum contract E (in the appropriately safe manner; more on that later).  If the primary Ethereum chain changes, this transaction may not be valid — E may not even have sufficient balance.  Without diving into the runtime behavior of both contracts, the only thing to do is to remove the transaction connecting E and F entirely.  The contracts F for which this must be done are identifiable simply from their input contract list.



